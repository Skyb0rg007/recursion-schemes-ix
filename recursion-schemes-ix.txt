-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Recursion schemes over indexed Functors
--   
--   Please see the README on GitHub at
--   <a>https://github.com/Skyb0rg007/recursion-schemes-ix#readme</a>
@package recursion-schemes-ix
@version 0.1.0.0

module Data.IFunction

-- | Indexed function type
type a ~~> b = forall ix. SingI ix => a ix -> b ix
infixr 4 ~~>

module Data.IFunctor

-- | Functor in the category of dependent types
class IFunctor f
imap :: IFunctor f => (a ~~> b) -> f a ~~> f b

-- | Indexed function type
type a ~~> b = forall ix. SingI ix => a ix -> b ix
infixr 4 ~~>
instance forall k (a :: k -> *). Data.IFunctor.IFunctor (Data.Functor.Sum.Sum a)
instance forall k (a :: k -> *). Data.IFunctor.IFunctor (Data.Functor.Product.Product a)

module Data.IComonad

-- | Comonoid in the category of dependent endofunctors
class IFunctor f => IComonad f
iextract :: IComonad f => f a ~~> a
iduplicate :: IComonad f => f a ~~> f (f a)
iextend :: IComonad f => (f a ~~> b) -> f a ~~> f b

-- | Indexed function type
type a ~~> b = forall ix. SingI ix => a ix -> b ix
infixr 4 ~~>

-- | Functor in the category of dependent types
class IFunctor f
imap :: IFunctor f => (a ~~> b) -> f a ~~> f b
instance forall k (a :: k -> *). Data.IComonad.IComonad (Data.Functor.Product.Product a)

module Data.IFunctor.Classes
class IShow f
ishowsPrec :: (IShow f, SingI ix) => (forall ix. SingI ix => Int -> a ix -> ShowS) -> Int -> f a ix -> ShowS
ishow :: (IShow f, SingI ix) => (forall ix. SingI ix => Int -> a ix -> ShowS) -> f a ix -> String
class IShow2 a
ishowsPrec2 :: (IShow2 a, SingI ix) => Int -> a ix -> ShowS
ishow2 :: (IShow2 a, SingI ix) => a ix -> String
ishowsPrec1 :: (IShow f, IShow2 a, SingI ix) => Int -> f a ix -> ShowS
ishow1 :: (IShow f, IShow2 a, SingI ix) => f a ix -> String
class IRead f
ireadPrec :: (IRead f, SingI ix) => (forall ix. SingI ix => ReadPrec (a ix)) -> ReadPrec (f a ix)
ireadsPrec :: (IRead f, SingI ix) => (forall ix. SingI ix => Int -> ReadS (a ix)) -> Int -> ReadS (f a ix)
class IRead2 a
ireadPrec2 :: (IRead2 a, SingI ix) => ReadPrec (a ix)
ireadsPrec2 :: (IRead2 a, SingI ix) => Int -> ReadS (a ix)
ireadPrec1 :: (IRead f, IRead2 a, SingI ix) => ReadPrec (f a ix)
ireadsPrec1 :: (IRead f, IRead2 a, SingI ix) => Int -> ReadS (f a ix)
class IEq f
ieq :: (IEq f, SingI ix) => (forall ix. SingI ix => a ix -> a ix -> Bool) -> f a ix -> f a ix -> Bool
class IEq2 a
ieq2 :: (IEq2 a, SingI ix) => a ix -> a ix -> Bool
ieq1 :: (IEq f, IEq2 a, SingI ix) => f a ix -> f a ix -> Bool
class IEq f => IOrd f
icompare :: (IOrd f, SingI ix) => (forall ix. SingI ix => a ix -> a ix -> Ordering) -> f a ix -> f a ix -> Ordering
class IEq2 a => IOrd2 a
icompare2 :: (IOrd2 a, SingI ix) => a ix -> a ix -> Ordering
icompare1 :: (IOrd f, IOrd2 a, SingI ix) => f a ix -> f a ix -> Ordering
instance forall k (a :: k -> *). Data.IFunctor.Classes.IOrd2 a => Data.IFunctor.Classes.IOrd (Data.Functor.Sum.Sum a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IOrd2 a => Data.IFunctor.Classes.IOrd (Data.Functor.Product.Product a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IEq2 a => Data.IFunctor.Classes.IEq (Data.Functor.Sum.Sum a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IEq2 a => Data.IFunctor.Classes.IEq (Data.Functor.Product.Product a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IRead2 a => Data.IFunctor.Classes.IRead (Data.Functor.Sum.Sum a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IRead2 a => Data.IFunctor.Classes.IRead (Data.Functor.Product.Product a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IShow2 a => Data.IFunctor.Classes.IShow (Data.Functor.Sum.Sum a)
instance forall k (a :: k -> *). Data.IFunctor.Classes.IShow2 a => Data.IFunctor.Classes.IShow (Data.Functor.Product.Product a)

module Data.IMonad
class IFunctor f => IMonad f
ipure :: IMonad f => a ~~> f a
ijoin :: IMonad f => f (f a) ~~> f a
ibind :: IMonad f => (a ~~> f b) -> f a ~~> f b

-- | Indexed function type
type a ~~> b = forall ix. SingI ix => a ix -> b ix
infixr 4 ~~>

-- | Functor in the category of dependent types
class IFunctor f
imap :: IFunctor f => (a ~~> b) -> f a ~~> f b
instance forall k (a :: k -> *). Data.IMonad.IMonad (Data.Functor.Sum.Sum a)

module Data.ITraversable
class IFunctor f => ITraversable f
itraverse :: (ITraversable f, Applicative m, SingI ix) => (forall ix. SingI ix => a ix -> m (b ix)) -> f a ix -> m (f b ix)

-- | Default <a>imap</a> for deriving <a>IFunctor</a>
imapDefault :: ITraversable f => (a ~~> b) -> f a ~~> f b
instance forall k (a :: k -> *). Data.ITraversable.ITraversable (Data.Functor.Sum.Sum a)
instance forall k (a :: k -> *). Data.ITraversable.ITraversable (Data.Functor.Product.Product a)

module Data.IFunctor.IIdentity
data IIdentity f ix
IIdentity :: f ix -> IIdentity f ix
[runIIdentity] :: IIdentity f ix -> f ix
instance forall k (f :: k -> *). GHC.Generics.Generic1 (Data.IFunctor.IIdentity.IIdentity f)
instance forall k (f :: k -> *) (ix :: k). GHC.Generics.Generic (Data.IFunctor.IIdentity.IIdentity f ix)
instance forall k (f :: k -> *) (ix :: k). (Data.Typeable.Internal.Typeable ix, Data.Typeable.Internal.Typeable f, Data.Typeable.Internal.Typeable k, Data.Data.Data (f ix)) => Data.Data.Data (Data.IFunctor.IIdentity.IIdentity f ix)
instance Data.IFunctor.IFunctor Data.IFunctor.IIdentity.IIdentity
instance Data.IMonad.IMonad Data.IFunctor.IIdentity.IIdentity
instance Data.IComonad.IComonad Data.IFunctor.IIdentity.IIdentity
instance Data.ITraversable.ITraversable Data.IFunctor.IIdentity.IIdentity
instance Data.IFunctor.Classes.IShow Data.IFunctor.IIdentity.IIdentity
instance Data.IFunctor.Classes.IRead Data.IFunctor.IIdentity.IIdentity
instance Data.IFunctor.Classes.IEq Data.IFunctor.IIdentity.IIdentity
instance Data.IFunctor.Classes.IOrd Data.IFunctor.IIdentity.IIdentity
instance forall k (f :: k -> *) (ix :: k). (Data.IFunctor.Classes.IShow2 f, Singlethongs.Internal.SingI ix) => GHC.Show.Show (Data.IFunctor.IIdentity.IIdentity f ix)
instance forall k (f :: k -> *) (ix :: k). (Data.IFunctor.Classes.IRead2 f, Singlethongs.Internal.SingI ix) => GHC.Read.Read (Data.IFunctor.IIdentity.IIdentity f ix)
instance forall k (f :: k -> *) (ix :: k). (Data.IFunctor.Classes.IEq2 f, Singlethongs.Internal.SingI ix) => GHC.Classes.Eq (Data.IFunctor.IIdentity.IIdentity f ix)
instance forall k (f :: k -> *) (ix :: k). (Data.IFunctor.Classes.IOrd2 f, Singlethongs.Internal.SingI ix) => GHC.Classes.Ord (Data.IFunctor.IIdentity.IIdentity f ix)

module Data.IFunctor.IFree

-- | Free IMonad
data IFree f a ix
IPure :: a ix -> IFree f a ix
IFree :: f (IFree f a) ix -> IFree f a ix
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *). GHC.Generics.Generic1 (Data.IFunctor.IFree.IFree f a)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). GHC.Generics.Generic (Data.IFunctor.IFree.IFree f a ix)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.IFunctor f => Data.IFunctor.IFunctor (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *). Data.ITraversable.ITraversable f => Data.ITraversable.ITraversable (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.IFunctor f => Data.IMonad.IMonad (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IShow f => Data.IFunctor.Classes.IShow (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IRead f => Data.IFunctor.Classes.IRead (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IEq f => Data.IFunctor.Classes.IEq (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IOrd f => Data.IFunctor.Classes.IOrd (Data.IFunctor.IFree.IFree f)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IShow f, Data.IFunctor.Classes.IShow2 a, Singlethongs.Internal.SingI ix) => GHC.Show.Show (Data.IFunctor.IFree.IFree f a ix)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IRead f, Data.IFunctor.Classes.IRead2 a, Singlethongs.Internal.SingI ix) => GHC.Read.Read (Data.IFunctor.IFree.IFree f a ix)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IEq f, Data.IFunctor.Classes.IEq2 a, Singlethongs.Internal.SingI ix) => GHC.Classes.Eq (Data.IFunctor.IFree.IFree f a ix)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IOrd f, Data.IFunctor.Classes.IOrd2 a, Singlethongs.Internal.SingI ix) => GHC.Classes.Ord (Data.IFunctor.IFree.IFree f a ix)

module Data.IFunctor.ICofree

-- | Cofree IComonad
data ICofree f a ix
(::<) :: a ix -> f (ICofree f a) ix -> ICofree f a ix
infixr 5 ::<
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *). GHC.Generics.Generic1 (Data.IFunctor.ICofree.ICofree f a)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). GHC.Generics.Generic (Data.IFunctor.ICofree.ICofree f a ix)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.IFunctor f => Data.IFunctor.IFunctor (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *). Data.ITraversable.ITraversable f => Data.ITraversable.ITraversable (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.IFunctor f => Data.IComonad.IComonad (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IShow f => Data.IFunctor.Classes.IShow (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IRead f => Data.IFunctor.Classes.IRead (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IEq f => Data.IFunctor.Classes.IEq (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *). Data.IFunctor.Classes.IOrd f => Data.IFunctor.Classes.IOrd (Data.IFunctor.ICofree.ICofree f)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IShow f, Data.IFunctor.Classes.IShow2 a, Singlethongs.Internal.SingI ix) => GHC.Show.Show (Data.IFunctor.ICofree.ICofree f a ix)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IRead f, Data.IFunctor.Classes.IRead2 a, Singlethongs.Internal.SingI ix) => GHC.Read.Read (Data.IFunctor.ICofree.ICofree f a ix)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IEq f, Data.IFunctor.Classes.IEq2 a, Singlethongs.Internal.SingI ix) => GHC.Classes.Eq (Data.IFunctor.ICofree.ICofree f a ix)
instance forall k (f :: (k -> *) -> k -> *) (a :: k -> *) (ix :: k). (Data.IFunctor.Classes.IOrd f, Data.IFunctor.Classes.IOrd2 a, Singlethongs.Internal.SingI ix) => GHC.Classes.Ord (Data.IFunctor.ICofree.ICofree f a ix)

module Data.IFunctor.Foldable

-- | Fixpoint type
newtype IFix f ix
IFix :: f (IFix f) ix -> IFix f ix
[unIFix] :: IFix f ix -> f (IFix f) ix

-- | Catamorphism, ie. fold
cata :: IFunctor f => (f a ~~> a) -> IFix f ~~> a

-- | Fokkinga's prepromorphism
prepro :: IFunctor f => (forall b. f b ~~> f b) -> (f a ~~> a) -> IFix f ~~> a

-- | Paramorphism
para :: IFunctor f => (f (Product (IFix f) a) ~~> a) -> IFix f ~~> a

-- | Zygomorphism
zygo :: IFunctor f => (f b ~~> b) -> (f (Product b a) ~~> a) -> IFix f ~~> a

-- | Histomorphism
histo :: IFunctor f => (f (ICofree f a) ~~> a) -> IFix f ~~> a

-- | Anamorphism, ie. unfold
ana :: IFunctor f => (a ~~> f a) -> a ~~> IFix f

-- | Fokkinga's postpromorphism
postpro :: IFunctor f => (forall b. f b ~~> f b) -> (a ~~> f a) -> a ~~> IFix f

-- | Apomorphism
apo :: IFunctor f => (a ~~> f (Sum (IFix f) a)) -> a ~~> IFix f

-- | GApomorphism
gapo :: IFunctor f => (b ~~> f b) -> (a ~~> f (Sum b a)) -> a ~~> IFix f

-- | Futumorphism
futu :: IFunctor f => (a ~~> f (IFree f a)) -> a ~~> IFix f

-- | Hylomorphism, fold then unfold
hylo :: IFunctor f => (f b ~~> b) -> (a ~~> f a) -> a ~~> b

-- | Dynamorphism
dyna :: IFunctor f => (f (ICofree f b) ~~> b) -> (a ~~> f a) -> a ~~> b

-- | Chronomorphism
chrono :: IFunctor f => (f (ICofree f b) ~~> b) -> (a ~~> f (IFree f a)) -> a ~~> b

-- | Metamorphism TODO: ensure only 1 pass over structure
meta :: (IFunctor f, IFunctor g) => (f a ~~> a) -> (a ~~> b) -> (b ~~> g b) -> IFix f ~~> IFix g
elgot :: forall f a b. IFunctor f => (f a ~~> a) -> (b ~~> Sum a (f b)) -> b ~~> a
coelgot :: forall f a b. IFunctor f => (Product a (f b) ~~> b) -> (a ~~> f a) -> a ~~> b

-- | Monadic catamorphism
cataM :: (ITraversable f, Monad m) => (forall ix. SingI ix => f a ix -> m (a ix)) -> forall ix. SingI ix => IFix f ix -> m (a ix)

-- | Monadic Paramorphism
paraM :: (ITraversable f, Monad m) => (forall ix. SingI ix => f (Product (IFix f) a) ix -> m (a ix)) -> forall ix. SingI ix => IFix f ix -> m (a ix)

-- | Monadic anamorphism
anaM :: (ITraversable f, Monad m) => (forall ix. SingI ix => a ix -> m (f a ix)) -> forall ix. SingI ix => a ix -> m (IFix f ix)

-- | Monadic apomorphism
apoM :: (ITraversable f, Monad m) => (forall ix. SingI ix => a ix -> m (f (Sum (IFix f) a) ix)) -> forall ix. SingI ix => a ix -> m (IFix f ix)

-- | Monadic hylomorphism
hyloM :: (ITraversable f, Monad m) => (forall ix. SingI ix => f b ix -> m (b ix)) -> (forall ix. SingI ix => a ix -> m (f a ix)) -> forall ix. SingI ix => a ix -> m (b ix)

-- | Monadic dynamorphism
dynaM :: (ITraversable f, Monad m) => (forall ix. SingI ix => f (ICofree f b) ix -> m (b ix)) -> (forall ix. SingI ix => a ix -> m (f a ix)) -> forall ix. SingI ix => a ix -> m (b ix)

-- | Type of distribution laws A Constructive morphism means the second
--   part is a <a>IComonad</a> A Destructive morphism means the first part
--   is an <a>IMonad</a>
type DistLaw f g = forall a. f (g a) ~~> g (f a)
distCata :: IFunctor f => DistLaw f IIdentity
distPara :: IFunctor f => DistLaw f (Product (IFix f))
distZygo :: IFunctor f => (f b ~~> b) -> DistLaw f (Product b)
distHisto :: IFunctor f => DistLaw f (ICofree f)
distAna :: IFunctor f => DistLaw IIdentity f
distApo :: IFunctor f => DistLaw (Sum (IFix f)) f
distGApo :: IFunctor f => (b ~~> f b) -> DistLaw (Sum b) f
distFutu :: IFunctor f => DistLaw (IFree f) f

-- | Generalized fold
gfold :: forall f w a. (IFunctor f, IComonad w) => DistLaw f w -> (f (w a) ~~> a) -> IFix f ~~> a

-- | Generalized unfold
gunfold :: forall f m a. (IFunctor f, IMonad m) => DistLaw m f -> (a ~~> f (m a)) -> a ~~> IFix f

-- | Generalized hylomorphism
ghylo :: forall f w m a b. (IFunctor f, IComonad w, IMonad m) => DistLaw f w -> DistLaw m f -> (f (w b) ~~> b) -> (a ~~> f (m a)) -> a ~~> b

-- | Generalized prepromorphism
gprepro :: forall f w a. (IFunctor f, IComonad w) => DistLaw f w -> (forall c. f c ~~> f c) -> (f (w a) ~~> a) -> IFix f ~~> a

-- | Generalized postpromorphism
gpostpro :: forall f m a. (IFunctor f, IMonad m) => DistLaw m f -> (forall c. f c ~~> f c) -> (a ~~> f (m a)) -> a ~~> IFix f

-- | Generalized monadic fold
gfoldM :: forall f w m a. (ITraversable f, ITraversable w, IComonad w, Monad m) => DistLaw f w -> (forall ix. SingI ix => f (w a) ix -> m (a ix)) -> forall ix. SingI ix => IFix f ix -> m (a ix)

-- | Generalized monadic unfold
gunfoldM :: forall f m a x. (ITraversable f, ITraversable m, IMonad m, Monad x) => DistLaw m f -> (forall ix. SingI ix => a ix -> x (f (m a) ix)) -> forall ix. SingI ix => a ix -> x (IFix f ix)

-- | Generalized monadic hylomorphism
ghyloM :: forall f w m a b x. (ITraversable f, ITraversable w, ITraversable m, IComonad w, IMonad m, Monad x) => DistLaw f w -> DistLaw m f -> (forall ix. SingI ix => f (w b) ix -> x (b ix)) -> (forall ix. SingI ix => a ix -> x (f (m a) ix)) -> forall ix. SingI ix => a ix -> x (b ix)

-- | The <a>Const</a> functor.
newtype Const a (b :: k)
Const :: a -> Const a (b :: k)
[getConst] :: Const a (b :: k) -> a

-- | Lifted product of functors.
data Product (f :: k -> Type) (g :: k -> Type) (a :: k)
Pair :: f a -> g a -> Product (f :: k -> Type) (g :: k -> Type) (a :: k)

-- | Lifted sum of functors.
data Sum (f :: k -> Type) (g :: k -> Type) (a :: k)
InL :: f a -> Sum (f :: k -> Type) (g :: k -> Type) (a :: k)
InR :: g a -> Sum (f :: k -> Type) (g :: k -> Type) (a :: k)

-- | Comonoid in the category of dependent endofunctors
class IFunctor f => IComonad f
iextract :: IComonad f => f a ~~> a
iduplicate :: IComonad f => f a ~~> f (f a)
iextend :: IComonad f => (f a ~~> b) -> f a ~~> f b

-- | Indexed function type
type a ~~> b = forall ix. SingI ix => a ix -> b ix
infixr 4 ~~>

-- | Functor in the category of dependent types
class IFunctor f
imap :: IFunctor f => (a ~~> b) -> f a ~~> f b

-- | Cofree IComonad
data ICofree f a ix
(::<) :: a ix -> f (ICofree f a) ix -> ICofree f a ix
infixr 5 ::<

-- | Free IMonad
data IFree f a ix
IPure :: a ix -> IFree f a ix
IFree :: f (IFree f a) ix -> IFree f a ix
data IIdentity f ix
IIdentity :: f ix -> IIdentity f ix
[runIIdentity] :: IIdentity f ix -> f ix
class IFunctor f => IMonad f
ipure :: IMonad f => a ~~> f a
ijoin :: IMonad f => f (f a) ~~> f a
ibind :: IMonad f => (a ~~> f b) -> f a ~~> f b
class IFunctor f => ITraversable f
itraverse :: (ITraversable f, Applicative m, SingI ix) => (forall ix. SingI ix => a ix -> m (b ix)) -> f a ix -> m (f b ix)

-- | Default <a>imap</a> for deriving <a>IFunctor</a>
imapDefault :: ITraversable f => (a ~~> b) -> f a ~~> f b
class SingI (a :: k)
sing :: SingI a => Sing a
instance forall k (f :: (k -> *) -> k -> *). GHC.Generics.Generic1 (Data.IFunctor.Foldable.IFix f)
instance forall k (f :: (k -> *) -> k -> *) (ix :: k). GHC.Generics.Generic (Data.IFunctor.Foldable.IFix f ix)
instance forall k (f :: (k -> *) -> k -> *) (ix :: k). (Data.IFunctor.Classes.IShow f, Singlethongs.Internal.SingI ix) => GHC.Show.Show (Data.IFunctor.Foldable.IFix f ix)
instance forall k (f :: (k -> *) -> k -> *) (ix :: k). (Data.IFunctor.Classes.IRead f, Singlethongs.Internal.SingI ix) => GHC.Read.Read (Data.IFunctor.Foldable.IFix f ix)
instance forall k (f :: (k -> *) -> k -> *) (ix :: k). (Data.IFunctor.Classes.IEq f, Singlethongs.Internal.SingI ix) => GHC.Classes.Eq (Data.IFunctor.Foldable.IFix f ix)
instance forall k (f :: (k -> *) -> k -> *) (ix :: k). (Data.IFunctor.Classes.IOrd f, Singlethongs.Internal.SingI ix) => GHC.Classes.Ord (Data.IFunctor.Foldable.IFix f ix)
